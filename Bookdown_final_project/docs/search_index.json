[["index.html", "Condor Data Organization RDS FInal Project Chapter 1 About", " Condor Data Organization RDS FInal Project Anne-Laure Blanche 2023-05-01 Chapter 1 About This is a bookdown book written in Markdown. "],["intro---database-structure.html", "Chapter 2 Intro - Database Structure 2.1 Designing the Database 2.2 Coding the database", " Chapter 2 Intro - Database Structure This chapter describes the process of designing and building my database. 2.1 Designing the Database 2.1.1 Tables The first summer’s data was already collected. Data was sorted into 4 tables. The first table is Condor_individuals, which holds information on each condor and its characteristics, such as sex and birth date. The second table is Carcasses, which stores carcass information such as when I put out each carcass, carcass weight, and habitat information on each carcass location. The third table, Video_metadata, includes data that helped me to organize during the field season and afterwards when looking at videos, such as the video id number, name of the SD card that the video is on, and carcass descriptions. The fourth excel sheet is names Visits. It holds all observations of visits by any scavenger, and information pertaining to that visit, such as duration of visit, weather condition at arrival, and times spent doing different activities, such as feeding time. ### Organization Once I organize data into tables, I can create a relational flowchart showing how the tables are related. knitr::include_graphics(“Relational_flowchart.PNG”) 2.2 Coding the database First I loaded the package DBI, which allows communication between R and the relational database, in this case, SQL. library(DBI) ## Warning: package &#39;DBI&#39; was built under R version 4.2.2 Then I can create and connect to a relational database, in this case, called “condors”, and storing it within an object also called “Condors” Condors &lt;- dbConnect(RSQLite::SQLite(), &quot;condors.db&quot;) 2.2.1 Creating tables Now I can begin building tables. I’ll start with Condor_individuals. The code below creates a blank table called Condor_individuals with columns for Condor_ID, Studbook_Number, Sex, Birthdate, et cetera. The type of data that can fit within each column is specified after the column name. For example, Sex is a single character, while Paired_with_2022 is an integer that can contain 4 numbers (as this is the studbook number of the condor that that individual was paired with in 2022, and studbook numbers can be up to 4 integers). At the end, PRIMARY KEY denotes which column acts as the unique identifier for each row. dbExecute(Condors, &quot;CREATE TABLE Condor_individuals ( Condor_ID char(2) NOT NULL, Studbook_Number int(4), Sex char(1), Birthdate date, Paired_with_2022 int(4), Paired_with_2023 int(4), Biological_offspring varchar(500), Biological_siblings varchar(500), PRIMARY KEY (Condor_ID) );&quot;) This pattern is continued for creating other tables. At the end of tables with columns that reference other columns in other tables, I included the following code right after my last column: FOREIGN KEY(Column_in_this_table) REFERENCES Other_table(Column_in_other_table) So, for example, this creates an appended version of my Visits table. I have removed several columns for clarity. The last two lines are creating relations between tables, so that the Carcass column is linked to ID_numer within the Carcasses table, and Individual column is linked to Condor_ID column in Condor_individuals table. dbExecute(Condors, &quot;CREATE TABLE Visits ( ID INTEGER PRIMARY KEY, Visit_per_individual int(2), Carcass int(3), Species varchar(15), Individual varchar(2), Time_arrive time, Wind int(1), Temp int(3), %_eaten_at_arrival int(3), Time_leave time, %_eaten_at_leaving int(3), Feeding_time double, Vigilance_time double, Out_of_frame/unsure double, FOREIGN KEY(Carcass) REFERENCES Carcasses(ID_number) FOREIGN KEY(Individual) REFERENCES Condor_individuals(Condor_ID) );&quot;) 2.2.2 Adding data to tables Now that empty tables exist, data can be put into them. I simply read my file containing my data into a new object and then append that table, including all the rows of data, with the empty tables I just created. This combines all my data with the empty table containing all the rules (for example, that the column can only contain rows of a single integer). Visits&lt;-read.csv(&quot;C:/Users/albla/OneDrive - USU/Thesis Research/Visits.csv&quot;, stringsAsFactors=FALSE) dbWriteTable(Condors,&quot;Visits&quot;,Visits,append=TRUE) I made sure to check that the data was loaded in using dbGetQuery(Condors, &quot;SELECT * FROM Visits LIMIT 10;&quot;) which prints the first 10 rows of data from the table Visits. "],["cleaning-data.html", "Chapter 3 Cleaning Data 3.1 Loading initial data and packages 3.2 Cleaning the data 3.3 Connecting to database", " Chapter 3 Cleaning Data This chapter describes the process I used to clean my Metadata sheet 3.1 Loading initial data and packages For this section, I used packages DBI and tidyverse. library(DBI) library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 4.2.2 ## ── Attaching packages ──────────── tidyverse 1.3.2 ── ## ✔ ggplot2 3.3.6 ✔ purrr 0.3.4 ## ✔ tibble 3.1.8 ✔ dplyr 1.0.10 ## ✔ tidyr 1.2.1 ✔ stringr 1.4.1 ## ✔ readr 2.1.3 ✔ forcats 0.5.2 ## ── Conflicts ─────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() The following code was used to load my data files: Video_metadata&lt;-read.csv(&quot;../../Homework/Data_files/Video_metadata.csv&quot;) I changed two column names as they had periods, which could interfere with coding down the line: colnames(Video_metadata)[5]&lt;-&quot;Close_wide&quot; colnames(Video_metadata)[10]&lt;-&quot;Still_on_SD_card&quot; I also loaded a couple functions I wanted to use later on: rowShift &lt;- function(x, shiftLen = 1L) { r &lt;- (1L + shiftLen):(length(x) + shiftLen) r[r&lt;1] &lt;- NA return(x[r]) } `%nin%` = Negate(`%in%`) rowShift allows me to call a different row from a column when changing my “See previous row” into data that isn’t dependent on order %nin% is quicker than calling every possible integer and rather specifying the couple I do not want, similar to != 3.2 Cleaning the data I first checked how many different names I used for my carcasses. unique(Video_metadata$Species) ## [1] &quot;Ewe&quot; &quot;Ewe &quot; &quot;ewe&quot; &quot;Lamb&quot; &quot;lamb&quot; &quot;Neotoma&quot; ## [7] &quot;Deer&quot; &quot;badger&quot; &quot;chipmunk&quot; &quot;calf&quot; &quot;&quot; &quot;deer&quot; ## [13] &quot;raccoon&quot; &quot;carp&quot; &quot;cat&quot; &quot;cow&quot; I was able to use a long pipe to clean all my data. There are several chunks, and I have split it accordingly: Video_metadata &lt;- Video_metadata %&gt;% mutate(Species = case_when( Species %in% c(&quot;Ewe&quot;, &quot;Ewe &quot;, &quot;ewe&quot;) ~ &quot;ewe&quot;, Species %in% c(&quot;Lamb&quot;, &quot;lamb&quot;) ~ &quot;lamb&quot;, Species %in% c(&quot;Neotoma&quot;, &quot;chipmunk&quot;) ~ &quot;rodent&quot;, Species %in% &quot;raccoon&quot; ~ &quot;raccoon&quot;, Species %in% &quot;carp&quot; ~ &quot;carp&quot;, Species %in% &quot;calf&quot; ~ &quot;calf&quot;, Species %in% &quot;cow&quot; ~ &quot;cow&quot;, Species %in% &quot;badger&quot; ~ &quot;badger&quot;, Species %in% c(&quot;Deer&quot;, &quot;deer&quot;) ~ &quot;deer&quot;, Species %in% &quot;cat&quot; ~ &quot;cat&quot;, Species %in% &quot;&quot; ~ &quot;DOUBLE CHECK&quot; )) # %&gt;% This cleans up all my different “species” into recognizable carcass groups. I didn’t want to just use sheep and cattle, but instead differentiating between adult/young since there is a large size difference (and although I have weight later on, this is helpful for recognition). I also included a “Double check” group since I have some blanks, that I haven’t entered in yet. mutate(Still_on_SD_card = case_when( Still_on_SD_card == &quot;Yes&quot; ~ &quot;Yes&quot;, Still_on_SD_card == &quot;Erased&quot; ~ &quot;Erased&quot;, SD_card == &quot;&quot; ~ &quot;Probably erased&quot; )) %&gt;% The next chunk does a similar role, with the column identifying whether the video is still on an SD card. I reclassified all blanks as probably erased, as I have entered in most SD card numbers. However, I wanted to keep there separate from Erased since I’m not entirely certain about this and should go back to check. mutate(Any_Video = case_when( Video %in% c(&quot;eh&quot;, &quot;y&quot;) ~ &quot;yes&quot;, Video == &quot;n&quot; ~ &quot;no&quot;, Video == &quot;see above&quot; ~ rowShift(Video, -1) )) %&gt;% relocate(Any_Video, .after = Video) %&gt;% mutate(Any_Video = case_when( Video == &quot;n&quot; ~ &quot;no&quot;, Video %in% c(&quot;eh&quot;, &quot;y&quot;) ~ &quot;yes&quot; )) %&gt;% This is again similar. I had one column about whether I had video from the visit, but I was using this both for useful and any video (think grass swaying in the wind, with no visits from scavengers). I had called this “eh”, and here I separate the eh into no for useful video, but yes for any video. I also relocated the Any_video next to Video so I could check my work and that everything looked correct. mutate(Useful_Video = case_when( Video == &quot;y&quot; ~ &quot;yes&quot;, Video %in% c(&quot;eh&quot;, &quot;n&quot;) ~ &quot;no&quot; )) %&gt;% After I transferred data from video to Useful_Video, I mutated the data again to conform to the previous “yes”/“no” rather than y/n that was in the Video column. mutate(Close_wide = case_when( Visit %nin% c(&quot;NA&quot;,&quot;&quot;) &amp; Close_wide == &quot;wide&quot; ~ &quot;wide&quot;, Visit %nin% c(&quot;NA&quot;,&quot;&quot;) &amp; Close_wide == &quot;close&quot; ~ &quot;close&quot;, Visit %in% c(&quot;NA&quot;,&quot;&quot;) &amp; Close_wide == &quot;&quot; ~ &quot;NA&quot;, Visit %nin% c(&quot;NA&quot;,&quot;&quot;) &amp; Close_wide %in% c(&quot;&quot;,&quot;.&quot;) ~ &quot;only&quot; )) I used my “not in” function to find the Visits that had values (ie wasn’t blank or NA). Close_wide describes camera placement, as I usually had a camera closer and one farther away (giving a wider angle view). If Visits is blank or NA that means I haven’t gotten to it yet, and Close_wide should also be blank. However, if Close_wide is blank with a value for Visit, it means only one camera was there, so I should label it as “only”. I briefly also used a period to designate “only” so I included that as well. 3.3 Connecting to database Now that the data is cleaned, I can connect it to the condors database and have the database run all the specified checks. Condors &lt;- dbConnect(RSQLite::SQLite(), &quot;condors.db&quot;) dbExecute(Condors, &quot;CREATE TABLE metadata ( Video_ID INTEGER PRIMARY KEY AUTOINCREMENT, Carcass char(3), Description varchar(25), Species varchar(15), Visit varchar(5), Close_wide varchar(6) CHECK (Close_wide IN (&#39;only&#39;,&#39;close&#39;,&#39;wide&#39;, &#39;NA&#39;)), Box_drive varchar(3) CHECK (Box_drive IN (&#39;Yes&#39;,&#39;No&#39;,&#39;&#39;)), External_Hard_Drive varchar(3) CHECK (External_Hard_drive IN (&#39;Yes&#39;,&#39;No&#39;,&#39;&#39;)), Scored_on_BORIS varchar(3) CHECK (Scored_on_BORIS IN (&#39;Yes&#39;,&#39;No&#39;,&#39;&#39;)), Need_to_time_offset char(3), Still_on_SD_card varchar(3) CHECK (Still_on_SD_card IN (&#39;Yes&#39;,&#39;Erased&#39;,&#39;Probably erased&#39;)), SD_card varchar(10), Video varchar(20), Any_Video varchar(20), Condors varchar(20), Comments varchar(50), Useful_Video varchar(20), FOREIGN KEY(Carcass) REFERENCES Carcasses(ID_number) );&quot;) dbWriteTable(Condors,&quot;metadata&quot;,Video_metadata,append=TRUE) This ran well and all my data looks good! "],["plotting.html", "Chapter 4 Plotting", " Chapter 4 Plotting I wanted to plot a simple graph of the number of carcasses of each species that I had from the past summer of fieldwork. I used the package ggplot2 for this. ggplot(Video_metadata, aes(x=Species, fill = Species))+ geom_bar()+ theme_bw()+ theme(legend.position = &quot;none&quot;) This was a very simple graph. I used a barplot with each species having a different color. Because we already have labels on the axes, I removed the legend. Theme black and white looked nice with this simple design. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
